set -eu
DEPLOY_DIR="$(dirname $(readlink -f $0))"

# Generate main script. This will be run as root when install.sh is executed
cat <<EOF > "${DEPLOY_DIR}/deploy.sh"
# This file is generated by ${DEPLOY_DIR}/deploy.sh, do not alter
(cd ${DEPLOY_DIR}/.. && \
    sudo -u "${DB_SUDO_USER}" ./build.sh "${DB_NAME}" "${DB_USER}" "${DB_PASS}"; \
    ) || exit 1
EOF

# Generate backup / restore convenience scripts
cat <<EOF > "${DEPLOY_DIR}/db_dump"
# This file is generated by ${DEPLOY_DIR}/deploy.sh, do not alter
sudo -u "${DB_SUDO_USER}" pg_dump --format=c --no-owner "${DB_NAME}" > ${1-clic.dump}
EOF
chmod a+x -- "${DEPLOY_DIR}/db_dump"
cat <<EOF > "${DEPLOY_DIR}/db_restore"
# This file is generated by ${DEPLOY_DIR}/deploy.sh, do not alter
set -e

systemctl stop ${PROJECT_NAME}

# NB: We don't use --clean --create since the DB_NAME in the dump might not be the one we want
sudo -u "${DB_SUDO_USER}" dropdb "${DB_NAME}" || true
sudo -u "${DB_SUDO_USER}" createdb "${DB_NAME}"
sudo -u "${DB_SUDO_USER}" pg_restore --format=c -d "${DB_NAME}" --verbose ${1-clic.dump}

# Re-run build.sh to make sure DB is sane
(cd ${DEPLOY_DIR}/.. && \
    sudo -u "${DB_SUDO_USER}" ./build.sh "${DB_NAME}" "${DB_USER}" "${DB_PASS}"; \
    )
EOF
chmod a+x -- "${DEPLOY_DIR}/db_restore"
